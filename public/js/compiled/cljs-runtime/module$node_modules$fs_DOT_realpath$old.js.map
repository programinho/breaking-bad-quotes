{
"version":3,
"file":"module$node_modules$fs_DOT_realpath$old.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/fs_DOT_realpath/old.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$fs_DOT_realpath$old\"] = function(global,require,module,exports) {\nvar process = require('process');\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","rethrow","debugCallback","err","backtrace","message","missingCallback","process","throwDeprecation","noDeprecation","msg","stack","traceDeprecation","console","trace","error","DEBUG","Error","callback","pathModule","isWindows","platform","fs","env","NODE_DEBUG","test","nextPartRe","splitRootRe","realpathSync","exports.realpathSync","p","cache","start","m","exec","pos","length","current","base","previous","knownHard","lstatSync","resolve","Object","prototype","hasOwnProperty","call","original","seenLinks","lastIndex","result","resolvedLink","stat","isSymbolicLink","linkTarget","id","dev","toString","ino","statSync","readlinkSync","slice","realpath","exports.realpath","cb","lstat","LOOP","nextTick","gotStat","gotTarget","readlink","target","bind"]
}
