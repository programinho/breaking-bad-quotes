["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/inflight/inflight.js"],"~:js","shadow$provide.module$node_modules$inflight$inflight=function(global,require,module,exports){function makeres(key){return once(function RES(){var cbs=reqs[key],len=cbs.length,args=slice(arguments);try{for(var i=0;i<len;i++)cbs[i].apply(null,args)}finally{cbs.length>len?(cbs.splice(0,len),process.nextTick(function(){RES.apply(null,args)})):delete reqs[key]}})}function slice(args){for(var length=args.length,array=[],i=0;i<length;i++)array[i]=args[i];return array}var process=require(\"module$node_modules$process$browser\");\nglobal=require(\"module$node_modules$wrappy$wrappy\");var reqs=Object.create(null),once=require(\"module$node_modules$once$once\");module.exports=global(function(key,cb){if(reqs[key])return reqs[key].push(cb),null;reqs[key]=[cb];return makeres(key)})}","~:source","shadow$provide[\"module$node_modules$inflight$inflight\"] = function(global,require,module,exports) {\nvar process = require('process');\nvar wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$shadow.js","~$module$node_modules$once$once","~$module$node_modules$wrappy$wrappy"]],"~:properties",["^5",[]],"~:compiled-at",1562407149197,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$inflight$inflight.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,sCAAA,CAA0D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkBlGC,QAASA,QAAQ,CAACC,GAAD,CAAM,CACrB,MAAOC,KAAA,CAAKC,QAASA,IAAI,EAAG,CAC1B,IAAIC,IAAMC,IAAA,CAAKJ,GAAL,CAAV,CACIK,IAAMF,GAAAG,OADV,CAEIC,KAAOC,KAAA,CAAMC,SAAN,CAQX,IAAI,CACF,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,GAApB,CAAyBK,CAAA,EAAzB,CACEP,GAAA,CAAIO,CAAJ,CAAAC,MAAA,CAAa,IAAb,CAAmBJ,IAAnB,CAFA,CAAJ,OAIU,CACJJ,GAAAG,OAAJ,CAAiBD,GAAjB,EAGEF,GAAAS,OAAA,CAAW,CAAX,CAAcP,GAAd,CACA,CAAAQ,OAAAC,SAAA,CAAiB,QAAS,EAAG,CAC3BZ,GAAAS,MAAA,CAAU,IAAV,CAAgBJ,IAAhB,CAD2B,CAA7B,CAJF,EAQE,OAAOH,IAAA,CAAKJ,GAAL,CATD,CAfgB,CAArB,CADc,CA+BvBQ,QAASA,MAAM,CAACD,IAAD,CAAO,CAIpB,IAHA,IAAID,OAASC,IAAAD,OAAb,CACIS,MAAQ,EADZ,CAGSL,EAAI,CAAb,CAAgBA,CAAhB,CAAoBJ,MAApB,CAA4BI,CAAA,EAA5B,CAAiCK,KAAA,CAAML,CAAN,CAAA,CAAWH,IAAA,CAAKG,CAAL,CAC5C,OAAOK,MALa,CAhDtB,IAAIF,QAAUjB,OAAA,CAAQ,qCAAR,CACVoB;MAAAA,CAASpB,OAAA,CAAQ,mCAAR,CACb,KAAIQ,KAAOa,MAAAC,OAAA,CAAc,IAAd,CAAX,CACIjB,KAAOL,OAAA,CAAQ,+BAAR,CAEXC,OAAAC,QAAA,CAAiBkB,MAAA,CAEjBG,QAAkB,CAACnB,GAAD,CAAMoB,EAAN,CAAU,CAC1B,GAAIhB,IAAA,CAAKJ,GAAL,CAAJ,CAEE,MADAI,KAAA,CAAKJ,GAAL,CAAAqB,KAAA,CAAeD,EAAf,CACO,CAAA,IAEPhB,KAAA,CAAKJ,GAAL,CAAA,CAAY,CAACoB,EAAD,CACZ,OAAOrB,QAAA,CAAQC,GAAR,CANiB,CAFX,CANiF;\",\n\"sources\":[\"node_modules/inflight/inflight.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$inflight$inflight\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\nvar wrappy = require('wrappy')\\nvar reqs = Object.create(null)\\nvar once = require('once')\\n\\nmodule.exports = wrappy(inflight)\\n\\nfunction inflight (key, cb) {\\n  if (reqs[key]) {\\n    reqs[key].push(cb)\\n    return null\\n  } else {\\n    reqs[key] = [cb]\\n    return makeres(key)\\n  }\\n}\\n\\nfunction makeres (key) {\\n  return once(function RES () {\\n    var cbs = reqs[key]\\n    var len = cbs.length\\n    var args = slice(arguments)\\n\\n    // XXX It's somewhat ambiguous whether a new callback added in this\\n    // pass should be queued for later execution if something in the\\n    // list of callbacks throws, or if it should just be discarded.\\n    // However, it's such an edge case that it hardly matters, and either\\n    // choice is likely as surprising as the other.\\n    // As it happens, we do go ahead and schedule it for later execution.\\n    try {\\n      for (var i = 0; i < len; i++) {\\n        cbs[i].apply(null, args)\\n      }\\n    } finally {\\n      if (cbs.length > len) {\\n        // added more in the interim.\\n        // de-zalgo, just in case, but don't call again.\\n        cbs.splice(0, len)\\n        process.nextTick(function () {\\n          RES.apply(null, args)\\n        })\\n      } else {\\n        delete reqs[key]\\n      }\\n    }\\n  })\\n}\\n\\nfunction slice (args) {\\n  var length = args.length\\n  var array = []\\n\\n  for (var i = 0; i < length; i++) array[i] = args[i]\\n  return array\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"makeres\",\"key\",\"once\",\"RES\",\"cbs\",\"reqs\",\"len\",\"length\",\"args\",\"slice\",\"arguments\",\"i\",\"apply\",\"splice\",\"process\",\"nextTick\",\"array\",\"wrappy\",\"Object\",\"create\",\"inflight\",\"cb\",\"push\"]\n}\n"]