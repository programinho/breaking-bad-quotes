["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/fs_DOT_realpath/old.js"],"~:js","shadow$provide.module$node_modules$fs_DOT_realpath$old=function(global,require,module,exports){function rethrow(){function debugCallback(err){err&&(backtrace.message=err.message,err=backtrace,missingCallback(err))}function missingCallback(err){if(err){if(process.throwDeprecation)throw err;process.noDeprecation||(err=\"fs: missing callback \"+(err.stack||err.message),process.traceDeprecation?console.trace(err):console.error(err))}}if(DEBUG){var backtrace=Error();var callback=debugCallback}else callback=\nmissingCallback;return callback}var process=require(\"module$node_modules$process$browser\"),pathModule=require(\"module$node_modules$path_browserify$index\"),isWindows=\"win32\"===process.platform,fs=require(\"shadow$empty\"),DEBUG=process.env.NODE_DEBUG&&/fs/.test(process.env.NODE_DEBUG),nextPartRe=isWindows?/(.*?)(?:[\\/\\\\]+|$)/g:/(.*?)(?:[\\/]+|$)/g,splitRootRe=isWindows?/^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/:/^[\\/]*/;exports.realpathSync=function(p,cache){function start(){var m=splitRootRe.exec(p);\npos=m[0].length;current=m[0];base=m[0];previous=\"\";isWindows&&!knownHard[base]&&(fs.lstatSync(base),knownHard[base]=!0)}p=pathModule.resolve(p);if(cache&&Object.prototype.hasOwnProperty.call(cache,p))return cache[p];var original=p,seenLinks={},knownHard={},current;for(start();pos<p.length;){nextPartRe.lastIndex=pos;var result=nextPartRe.exec(p);var previous=current;current+=result[0];var base=previous+result[1];var pos=nextPartRe.lastIndex;if(!(knownHard[base]||cache&&cache[base]===base)){if(cache&&\nObject.prototype.hasOwnProperty.call(cache,base))var resolvedLink=cache[base];else{resolvedLink=fs.lstatSync(base);if(!resolvedLink.isSymbolicLink()){knownHard[base]=!0;cache&&(cache[base]=base);continue}result=null;if(!isWindows){var id=resolvedLink.dev.toString(32)+\":\"+resolvedLink.ino.toString(32);seenLinks.hasOwnProperty(id)&&(result=seenLinks[id])}null===result&&(fs.statSync(base),result=fs.readlinkSync(base));resolvedLink=pathModule.resolve(previous,result);cache&&(cache[base]=resolvedLink);\nisWindows||(seenLinks[id]=result)}p=pathModule.resolve(resolvedLink,p.slice(pos));start()}}cache&&(cache[original]=p);return p};exports.realpath=function(p,cache,cb){function start(){var m=splitRootRe.exec(p);pos=m[0].length;current=m[0];base$jscomp$0=m[0];previous=\"\";isWindows&&!knownHard[base$jscomp$0]?fs.lstat(base$jscomp$0,function(err){if(err)return cb(err);knownHard[base$jscomp$0]=!0;LOOP()}):process.nextTick(LOOP)}function LOOP(){if(pos>=p.length)return cache&&(cache[original]=p),cb(null,p);\nnextPartRe.lastIndex=pos;var result=nextPartRe.exec(p);previous=current;current+=result[0];base$jscomp$0=previous+result[1];pos=nextPartRe.lastIndex;if(knownHard[base$jscomp$0]||cache&&cache[base$jscomp$0]===base$jscomp$0)return process.nextTick(LOOP);if(cache&&Object.prototype.hasOwnProperty.call(cache,base$jscomp$0))p=pathModule.resolve(cache[base$jscomp$0],p.slice(pos)),start();else return fs.lstat(base$jscomp$0,gotStat)}function gotStat(err$jscomp$1,stat){if(err$jscomp$1)return cb(err$jscomp$1);\nif(!stat.isSymbolicLink())return knownHard[base$jscomp$0]=!0,cache&&(cache[base$jscomp$0]=base$jscomp$0),process.nextTick(LOOP);if(!isWindows){var id=stat.dev.toString(32)+\":\"+stat.ino.toString(32);if(seenLinks.hasOwnProperty(id))return gotTarget(null,seenLinks[id],base$jscomp$0)}fs.stat(base$jscomp$0,function(err$jscomp$0){if(err$jscomp$0)return cb(err$jscomp$0);fs.readlink(base$jscomp$0,function(err,target){isWindows||(seenLinks[id]=target);gotTarget(err,target)})})}function gotTarget(err,target,\nbase){if(err)return cb(err);err=pathModule.resolve(previous,target);cache&&(cache[base]=err);p=pathModule.resolve(err,p.slice(pos));start()}\"function\"!==typeof cb&&(cb=\"function\"===typeof cache?cache:rethrow(),cache=null);p=pathModule.resolve(p);if(cache&&Object.prototype.hasOwnProperty.call(cache,p))return process.nextTick(cb.bind(null,null,cache[p]));var original=p,seenLinks={},knownHard={},pos,current,base$jscomp$0,previous;start()}}","~:source","shadow$provide[\"module$node_modules$fs_DOT_realpath$old\"] = function(global,require,module,exports) {\nvar process = require('process');\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$shadow$empty","~$shadow.js","~$module$node_modules$path_browserify$index"]],"~:properties",["^5",["message","realpathSync","lastIndex","realpath"]],"~:compiled-at",1562407149181,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$fs_DOT_realpath$old.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/fs_DOT_realpath/old.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$fs_DOT_realpath$old\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar pathModule = require('path');\\nvar isWindows = process.platform === 'win32';\\nvar fs = require('fs');\\n\\n// JavaScript implementation of realpath, ported from node pre-v6\\n\\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\\n\\nfunction rethrow() {\\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\\n  // is fairly slow to generate.\\n  var callback;\\n  if (DEBUG) {\\n    var backtrace = new Error;\\n    callback = debugCallback;\\n  } else\\n    callback = missingCallback;\\n\\n  return callback;\\n\\n  function debugCallback(err) {\\n    if (err) {\\n      backtrace.message = err.message;\\n      err = backtrace;\\n      missingCallback(err);\\n    }\\n  }\\n\\n  function missingCallback(err) {\\n    if (err) {\\n      if (process.throwDeprecation)\\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\\n      else if (!process.noDeprecation) {\\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\\n        if (process.traceDeprecation)\\n          console.trace(msg);\\n        else\\n          console.error(msg);\\n      }\\n    }\\n  }\\n}\\n\\nfunction maybeCallback(cb) {\\n  return typeof cb === 'function' ? cb : rethrow();\\n}\\n\\nvar normalize = pathModule.normalize;\\n\\n// Regexp that finds the next partion of a (partial) path\\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\\nif (isWindows) {\\n  var nextPartRe = /(.*?)(?:[\\\\/\\\\\\\\]+|$)/g;\\n} else {\\n  var nextPartRe = /(.*?)(?:[\\\\/]+|$)/g;\\n}\\n\\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\\\\\'.\\nif (isWindows) {\\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/][^\\\\\\\\\\\\/]+)?[\\\\\\\\\\\\/]*/;\\n} else {\\n  var splitRootRe = /^[\\\\/]*/;\\n}\\n\\nexports.realpathSync = function realpathSync(p, cache) {\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return cache[p];\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstatSync(base);\\n      knownHard[base] = true;\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  // NB: p.length changes.\\n  while (pos < p.length) {\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      continue;\\n    }\\n\\n    var resolvedLink;\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // some known symbolic link.  no need to stat again.\\n      resolvedLink = cache[base];\\n    } else {\\n      var stat = fs.lstatSync(base);\\n      if (!stat.isSymbolicLink()) {\\n        knownHard[base] = true;\\n        if (cache) cache[base] = base;\\n        continue;\\n      }\\n\\n      // read the link if it wasn't read before\\n      // dev/ino always return 0 on windows, so skip the check.\\n      var linkTarget = null;\\n      if (!isWindows) {\\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n        if (seenLinks.hasOwnProperty(id)) {\\n          linkTarget = seenLinks[id];\\n        }\\n      }\\n      if (linkTarget === null) {\\n        fs.statSync(base);\\n        linkTarget = fs.readlinkSync(base);\\n      }\\n      resolvedLink = pathModule.resolve(previous, linkTarget);\\n      // track this, if given a cache.\\n      if (cache) cache[base] = resolvedLink;\\n      if (!isWindows) seenLinks[id] = linkTarget;\\n    }\\n\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n\\n  if (cache) cache[original] = p;\\n\\n  return p;\\n};\\n\\n\\nexports.realpath = function realpath(p, cache, cb) {\\n  if (typeof cb !== 'function') {\\n    cb = maybeCallback(cache);\\n    cache = null;\\n  }\\n\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return process.nextTick(cb.bind(null, null, cache[p]));\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstat(base, function(err) {\\n        if (err) return cb(err);\\n        knownHard[base] = true;\\n        LOOP();\\n      });\\n    } else {\\n      process.nextTick(LOOP);\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  function LOOP() {\\n    // stop if scanned past end of path\\n    if (pos >= p.length) {\\n      if (cache) cache[original] = p;\\n      return cb(null, p);\\n    }\\n\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      return process.nextTick(LOOP);\\n    }\\n\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // known symbolic link.  no need to stat again.\\n      return gotResolvedLink(cache[base]);\\n    }\\n\\n    return fs.lstat(base, gotStat);\\n  }\\n\\n  function gotStat(err, stat) {\\n    if (err) return cb(err);\\n\\n    // if not a symlink, skip to the next path part\\n    if (!stat.isSymbolicLink()) {\\n      knownHard[base] = true;\\n      if (cache) cache[base] = base;\\n      return process.nextTick(LOOP);\\n    }\\n\\n    // stat & read the link if not read before\\n    // call gotTarget as soon as the link target is known\\n    // dev/ino always return 0 on windows, so skip the check.\\n    if (!isWindows) {\\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n      if (seenLinks.hasOwnProperty(id)) {\\n        return gotTarget(null, seenLinks[id], base);\\n      }\\n    }\\n    fs.stat(base, function(err) {\\n      if (err) return cb(err);\\n\\n      fs.readlink(base, function(err, target) {\\n        if (!isWindows) seenLinks[id] = target;\\n        gotTarget(err, target);\\n      });\\n    });\\n  }\\n\\n  function gotTarget(err, target, base) {\\n    if (err) return cb(err);\\n\\n    var resolvedLink = pathModule.resolve(previous, target);\\n    if (cache) cache[base] = resolvedLink;\\n    gotResolvedLink(resolvedLink);\\n  }\\n\\n  function gotResolvedLink(resolvedLink) {\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"rethrow\",\"debugCallback\",\"err\",\"backtrace\",\"message\",\"missingCallback\",\"process\",\"throwDeprecation\",\"noDeprecation\",\"msg\",\"stack\",\"traceDeprecation\",\"console\",\"trace\",\"error\",\"DEBUG\",\"Error\",\"callback\",\"pathModule\",\"isWindows\",\"platform\",\"fs\",\"env\",\"NODE_DEBUG\",\"test\",\"nextPartRe\",\"splitRootRe\",\"realpathSync\",\"exports.realpathSync\",\"p\",\"cache\",\"start\",\"m\",\"exec\",\"pos\",\"length\",\"current\",\"base\",\"previous\",\"knownHard\",\"lstatSync\",\"resolve\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"original\",\"seenLinks\",\"lastIndex\",\"result\",\"resolvedLink\",\"stat\",\"isSymbolicLink\",\"linkTarget\",\"id\",\"dev\",\"toString\",\"ino\",\"statSync\",\"readlinkSync\",\"slice\",\"realpath\",\"exports.realpath\",\"cb\",\"lstat\",\"LOOP\",\"nextTick\",\"gotStat\",\"gotTarget\",\"readlink\",\"target\",\"bind\"]\n}\n"]