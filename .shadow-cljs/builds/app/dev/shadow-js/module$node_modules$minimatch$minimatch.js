["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/minimatch/minimatch.js"],"~:js","shadow$provide.module$node_modules$minimatch$minimatch=function(global,require,module,exports){function ext(a,b){a=a||{};b=b||{};var t={};Object.keys(b).forEach(function(k){t[k]=b[k]});Object.keys(a).forEach(function(k){t[k]=a[k]});return t}function minimatch(p,pattern,options){if(\"string\"!==typeof pattern)throw new TypeError(\"glob pattern string required\");options||(options={});return options.nocomment||\"#\"!==pattern.charAt(0)?\"\"===pattern.trim()?\"\"===p:(new Minimatch(pattern,options)).match(p):\n!1}function Minimatch(pattern,options){if(!(this instanceof Minimatch))return new Minimatch(pattern,options);if(\"string\"!==typeof pattern)throw new TypeError(\"glob pattern string required\");options||(options={});pattern=pattern.trim();\"/\"!==path.sep&&(pattern=pattern.split(path.sep).join(\"/\"));this.options=options;this.set=[];this.pattern=pattern;this.regexp=null;this.empty=this.comment=this.negate=!1;this.make()}function braceExpand(pattern,options){options||(options=this instanceof Minimatch?this.options:\n{});pattern=\"undefined\"===typeof pattern?this.pattern:pattern;if(\"undefined\"===typeof pattern)throw new TypeError(\"undefined pattern\");return options.nobrace||!pattern.match(/\\{.*\\}/)?[pattern]:expand(pattern)}module.exports=minimatch;minimatch.Minimatch=Minimatch;var path={sep:\"/\"};try{path=require(\"module$node_modules$path_browserify$index\")}catch(er){}var GLOBSTAR=minimatch.GLOBSTAR=Minimatch.GLOBSTAR={},expand=require(\"module$node_modules$brace_expansion$index\"),plTypes={\"!\":{open:\"(?:(?!(?:\",\nclose:\"))[^/]*?)\"},\"?\":{open:\"(?:\",close:\")?\"},\"+\":{open:\"(?:\",close:\")+\"},\"*\":{open:\"(?:\",close:\")*\"},\"@\":{open:\"(?:\",close:\")\"}},reSpecials=function(s){return s.split(\"\").reduce(function(set,c){set[c]=!0;return set},{})}(\"().*{}+?[]^$\\\\!\"),slashSplit=/\\/+/;minimatch.filter=function(pattern,options){options=options||{};return function(p,i,list){return minimatch(p,pattern,options)}};minimatch.defaults=function(def){if(!def||!Object.keys(def).length)return minimatch;var m=function(p,pattern,options){return minimatch.minimatch(p,\npattern,ext(def,options))};m.Minimatch=function(pattern,options){return new minimatch.Minimatch(pattern,ext(def,options))};return m};Minimatch.defaults=function(def){return def&&Object.keys(def).length?minimatch.defaults(def).Minimatch:Minimatch};Minimatch.prototype.debug=function(){};Minimatch.prototype.make=function(){if(!this._made){var pattern=this.pattern,options=this.options;options.nocomment||\"#\"!==pattern.charAt(0)?pattern?(this.parseNegate(),pattern=this.globSet=this.braceExpand(),options.debug&&\n(this.debug=console.error),this.debug(this.pattern,pattern),pattern=this.globParts=pattern.map(function(s){return s.split(slashSplit)}),this.debug(this.pattern,pattern),pattern=pattern.map(function(s,si,set){return s.map(this.parse,this)},this),this.debug(this.pattern,pattern),pattern=pattern.filter(function(s){return-1===s.indexOf(!1)}),this.debug(this.pattern,pattern),this.set=pattern):this.empty=!0:this.comment=!0}};Minimatch.prototype.parseNegate=function(){var pattern=this.pattern,negate=!1,\nnegateOffset=0;if(!this.options.nonegate){for(var i=0,l=pattern.length;i<l&&\"!\"===pattern.charAt(i);i++)negate=!negate,negateOffset++;negateOffset&&(this.pattern=pattern.substr(negateOffset));this.negate=negate}};minimatch.braceExpand=function(pattern,options){return braceExpand(pattern,options)};Minimatch.prototype.braceExpand=braceExpand;Minimatch.prototype.parse=function(pattern,isSub){function clearStateChar(){if(stateChar){switch(stateChar){case \"*\":re+=\"[^/]*?\";hasMagic=!0;break;case \"?\":re+=\n\"[^/]\";hasMagic=!0;break;default:re+=\"\\\\\"+stateChar}self.debug(\"clearStateChar %j %j\",stateChar,re);stateChar=!1}}if(65536<pattern.length)throw new TypeError(\"pattern is too long\");var options=this.options;if(!options.noglobstar&&\"**\"===pattern)return GLOBSTAR;if(\"\"===pattern)return\"\";for(var re=\"\",hasMagic=!!options.nocase,escaping=!1,patternListStack=[],negativeLists=[],stateChar,inClass=!1,reClassStart=-1,classStart=-1,patternStart=\".\"===pattern.charAt(0)?\"\":options.dot?\"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\":\n\"(?!\\\\.)\",self=this,i=0,len=pattern.length,c;i<len&&(c=pattern.charAt(i));i++)if(this.debug(\"%s\\t%s %s %j\",pattern,i,re,c),escaping&&reSpecials[c])re+=\"\\\\\"+c,escaping=!1;else switch(c){case \"/\":return!1;case \"\\\\\":clearStateChar();escaping=!0;continue;case \"?\":case \"*\":case \"+\":case \"@\":case \"!\":this.debug(\"%s\\t%s %s %j \\x3c-- stateChar\",pattern,i,re,c);if(inClass){this.debug(\"  in class\");\"!\"===c&&i===classStart+1&&(c=\"^\");re+=c;continue}self.debug(\"call clearStateChar %j\",stateChar);clearStateChar();\nstateChar=c;options.noext&&clearStateChar();continue;case \"(\":if(inClass){re+=\"(\";continue}if(!stateChar){re+=\"\\\\(\";continue}patternListStack.push({type:stateChar,start:i-1,reStart:re.length,open:plTypes[stateChar].open,close:plTypes[stateChar].close});re+=\"!\"===stateChar?\"(?:(?!(?:\":\"(?:\";this.debug(\"plType %j %j\",stateChar,re);stateChar=!1;continue;case \")\":if(inClass||!patternListStack.length){re+=\"\\\\)\";continue}clearStateChar();hasMagic=!0;var pl=patternListStack.pop();re+=pl.close;\"!\"===pl.type&&\nnegativeLists.push(pl);pl.reEnd=re.length;continue;case \"|\":if(inClass||!patternListStack.length||escaping){re+=\"\\\\|\";escaping=!1;continue}clearStateChar();re+=\"|\";continue;case \"[\":clearStateChar();if(inClass){re+=\"\\\\\"+c;continue}inClass=!0;classStart=i;reClassStart=re.length;re+=c;continue;case \"]\":if(i===classStart+1||!inClass){re+=\"\\\\\"+c;escaping=!1;continue}if(inClass){pl=pattern.substring(classStart+1,i);try{RegExp(\"[\"+pl+\"]\")}catch(er$1){pl=this.parse(pl,SUBPARSE);re=re.substr(0,reClassStart)+\n\"\\\\[\"+pl[0]+\"\\\\]\";hasMagic=hasMagic||pl[1];inClass=!1;continue}}hasMagic=!0;inClass=!1;re+=c;continue;default:clearStateChar(),escaping?escaping=!1:!reSpecials[c]||\"^\"===c&&inClass||(re+=\"\\\\\"),re+=c}inClass&&(pl=pattern.substr(classStart+1),pl=this.parse(pl,SUBPARSE),re=re.substr(0,reClassStart)+\"\\\\[\"+pl[0],hasMagic=hasMagic||pl[1]);for(pl=patternListStack.pop();pl;pl=patternListStack.pop())i=re.slice(pl.reStart+pl.open.length),this.debug(\"setting tail\",re,pl),i=i.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g,\nfunction(_,$1,$2){$2||($2=\"\\\\\");return $1+$1+$2+\"|\"}),this.debug(\"tail\\x3d%j\\n   %s\",i,i,pl,re),reClassStart=\"*\"===pl.type?\"[^/]*?\":\"?\"===pl.type?\"[^/]\":\"\\\\\"+pl.type,hasMagic=!0,re=re.slice(0,pl.reStart)+reClassStart+\"\\\\(\"+i;clearStateChar();escaping&&(re+=\"\\\\\\\\\");escaping=!1;switch(re.charAt(0)){case \".\":case \"[\":case \"(\":escaping=!0}for(patternListStack=negativeLists.length-1;-1<patternListStack;patternListStack--){i=negativeLists[patternListStack];reClassStart=re.slice(0,i.reStart);classStart=\nre.slice(i.reStart,i.reEnd-8);len=re.slice(i.reEnd-8,i.reEnd);i=re.slice(i.reEnd);len+=i;c=reClassStart.split(\"(\").length-1;pl=i;for(i=0;i<c;i++)pl=pl.replace(/\\)[+*?]?/,\"\");i=pl;c=\"\";\"\"===i&&isSub!==SUBPARSE&&(c=\"$\");re=reClassStart+classStart+i+c+len}\"\"!==re&&hasMagic&&(re=\"(?\\x3d.)\"+re);escaping&&(re=patternStart+re);if(isSub===SUBPARSE)return[re,hasMagic];if(!hasMagic)return pattern.replace(/\\\\(.)/g,\"$1\");isSub=options.nocase?\"i\":\"\";try{var regExp=new RegExp(\"^\"+re+\"$\",isSub)}catch(er$2){return/$./}regExp._glob=\npattern;regExp._src=re;return regExp};var SUBPARSE={};minimatch.makeRe=function(pattern,options){return(new Minimatch(pattern,options||{})).makeRe()};Minimatch.prototype.makeRe=function(){if(this.regexp||!1===this.regexp)return this.regexp;var set=this.set;if(!set.length)return this.regexp=!1;var options=this.options,twoStar=options.noglobstar?\"[^/]*?\":options.dot?\"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\":\"(?:(?!(?:\\\\/|^)\\\\.).)*?\";options=options.nocase?\"i\":\"\";set=set.map(function(pattern){return pattern.map(function(p){return p===\nGLOBSTAR?twoStar:\"string\"===typeof p?p.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,\"\\\\$\\x26\"):p._src}).join(\"\\\\/\")}).join(\"|\");set=\"^(?:\"+set+\")$\";this.negate&&(set=\"^(?!\"+set+\").*$\");try{this.regexp=new RegExp(set,options)}catch(ex){this.regexp=!1}return this.regexp};minimatch.match=function(list,pattern,options){options=options||{};var mm=new Minimatch(pattern,options);list=list.filter(function(f){return mm.match(f)});mm.options.nonull&&!list.length&&list.push(pattern);return list};Minimatch.prototype.match=\nfunction(f,partial){this.debug(\"match\",f,this.pattern);if(this.comment)return!1;if(this.empty)return\"\"===f;if(\"/\"===f&&partial)return!0;var options=this.options;\"/\"!==path.sep&&(f=f.split(path.sep).join(\"/\"));f=f.split(slashSplit);this.debug(this.pattern,\"split\",f);var set=this.set;this.debug(this.pattern,\"set\",set);var filename,i;for(i=f.length-1;0<=i&&!(filename=f[i]);i--);for(i=0;i<set.length;i++){var pattern=set[i],file=f;options.matchBase&&1===pattern.length&&(file=[filename]);if(this.matchOne(file,\npattern,partial))return options.flipNegate?!0:!this.negate}return options.flipNegate?!1:this.negate};Minimatch.prototype.matchOne=function(file,pattern,partial){var options=this.options;this.debug(\"matchOne\",{\"this\":this,file:file,pattern:pattern});this.debug(\"matchOne\",file.length,pattern.length);for(var fi=0,pi=0,fl=file.length,pl=pattern.length;fi<fl&&pi<pl;fi++,pi++){this.debug(\"matchOne loop\");var p=pattern[pi],f=file[fi];this.debug(pattern,p,f);if(!1===p)return!1;if(p===GLOBSTAR){this.debug(\"GLOBSTAR\",\n[pattern,p,f]);p=fi;pi+=1;if(pi===pl){for(this.debug(\"** at the end\");fi<fl;fi++)if(\".\"===file[fi]||\"..\"===file[fi]||!options.dot&&\".\"===file[fi].charAt(0))return!1;return!0}for(;p<fl;){fi=file[p];this.debug(\"\\nglobstar while\",file,p,pattern,pi,fi);if(this.matchOne(file.slice(p),pattern.slice(pi),partial))return this.debug(\"globstar found match!\",p,fl,fi),!0;if(\".\"===fi||\"..\"===fi||!options.dot&&\".\"===fi.charAt(0)){this.debug(\"dot detected!\",file,p,pattern,pi);break}this.debug(\"globstar swallow a segment, and continue\");\np++}return partial&&(this.debug(\"\\n\\x3e\\x3e\\x3e no match, partial?\",file,p,pattern,pi),p===fl)?!0:!1}if(\"string\"===typeof p){var hit=options.nocase?f.toLowerCase()===p.toLowerCase():f===p;this.debug(\"string match\",p,f,hit)}else hit=f.match(p),this.debug(\"pattern match\",p,f,hit);if(!hit)return!1}if(fi===fl&&pi===pl)return!0;if(fi===fl)return partial;if(pi===pl)return fi===fl-1&&\"\"===file[fi];throw Error(\"wtf?\");}}","~:source","shadow$provide[\"module$node_modules$minimatch$minimatch\"] = function(global,require,module,exports) {\nmodule.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$brace_expansion$index","~$shadow.js","~$module$node_modules$path_browserify$index"]],"~:properties",["^5",["braceExpand","negate","sep","makeRe","globSet","GLOBSTAR","_src","Minimatch","reEnd","make","regexp","start","debug","filter","empty","close","reStart","pattern","type","_glob","match","parse","file","set","globParts","parseNegate","comment","open","options","matchOne","defaults"]],"~:compiled-at",1562407149188,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$minimatch$minimatch.js\",\n\"lineCount\":20,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/minimatch/minimatch.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$minimatch$minimatch\\\"] = function(global,require,module,exports) {\\nmodule.exports = minimatch\\nminimatch.Minimatch = Minimatch\\n\\nvar path = { sep: '/' }\\ntry {\\n  path = require('path')\\n} catch (er) {}\\n\\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\\nvar expand = require('brace-expansion')\\n\\nvar plTypes = {\\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\\n  '?': { open: '(?:', close: ')?' },\\n  '+': { open: '(?:', close: ')+' },\\n  '*': { open: '(?:', close: ')*' },\\n  '@': { open: '(?:', close: ')' }\\n}\\n\\n// any single thing other than /\\n// don't need to escape / when using new RegExp()\\nvar qmark = '[^/]'\\n\\n// * => any number of characters\\nvar star = qmark + '*?'\\n\\n// ** when dots are allowed.  Anything goes, except .. and .\\n// not (^ or / followed by one or two dots followed by $ or /),\\n// followed by anything, any number of times.\\nvar twoStarDot = '(?:(?!(?:\\\\\\\\\\\\/|^)(?:\\\\\\\\.{1,2})($|\\\\\\\\\\\\/)).)*?'\\n\\n// not a ^ or / followed by a dot,\\n// followed by anything, any number of times.\\nvar twoStarNoDot = '(?:(?!(?:\\\\\\\\\\\\/|^)\\\\\\\\.).)*?'\\n\\n// characters that need to be escaped in RegExp.\\nvar reSpecials = charSet('().*{}+?[]^$\\\\\\\\!')\\n\\n// \\\"abc\\\" -> { a:true, b:true, c:true }\\nfunction charSet (s) {\\n  return s.split('').reduce(function (set, c) {\\n    set[c] = true\\n    return set\\n  }, {})\\n}\\n\\n// normalizes slashes.\\nvar slashSplit = /\\\\/+/\\n\\nminimatch.filter = filter\\nfunction filter (pattern, options) {\\n  options = options || {}\\n  return function (p, i, list) {\\n    return minimatch(p, pattern, options)\\n  }\\n}\\n\\nfunction ext (a, b) {\\n  a = a || {}\\n  b = b || {}\\n  var t = {}\\n  Object.keys(b).forEach(function (k) {\\n    t[k] = b[k]\\n  })\\n  Object.keys(a).forEach(function (k) {\\n    t[k] = a[k]\\n  })\\n  return t\\n}\\n\\nminimatch.defaults = function (def) {\\n  if (!def || !Object.keys(def).length) return minimatch\\n\\n  var orig = minimatch\\n\\n  var m = function minimatch (p, pattern, options) {\\n    return orig.minimatch(p, pattern, ext(def, options))\\n  }\\n\\n  m.Minimatch = function Minimatch (pattern, options) {\\n    return new orig.Minimatch(pattern, ext(def, options))\\n  }\\n\\n  return m\\n}\\n\\nMinimatch.defaults = function (def) {\\n  if (!def || !Object.keys(def).length) return Minimatch\\n  return minimatch.defaults(def).Minimatch\\n}\\n\\nfunction minimatch (p, pattern, options) {\\n  if (typeof pattern !== 'string') {\\n    throw new TypeError('glob pattern string required')\\n  }\\n\\n  if (!options) options = {}\\n\\n  // shortcut: comments match nothing.\\n  if (!options.nocomment && pattern.charAt(0) === '#') {\\n    return false\\n  }\\n\\n  // \\\"\\\" only matches \\\"\\\"\\n  if (pattern.trim() === '') return p === ''\\n\\n  return new Minimatch(pattern, options).match(p)\\n}\\n\\nfunction Minimatch (pattern, options) {\\n  if (!(this instanceof Minimatch)) {\\n    return new Minimatch(pattern, options)\\n  }\\n\\n  if (typeof pattern !== 'string') {\\n    throw new TypeError('glob pattern string required')\\n  }\\n\\n  if (!options) options = {}\\n  pattern = pattern.trim()\\n\\n  // windows support: need to use /, not \\\\\\n  if (path.sep !== '/') {\\n    pattern = pattern.split(path.sep).join('/')\\n  }\\n\\n  this.options = options\\n  this.set = []\\n  this.pattern = pattern\\n  this.regexp = null\\n  this.negate = false\\n  this.comment = false\\n  this.empty = false\\n\\n  // make the set of regexps etc.\\n  this.make()\\n}\\n\\nMinimatch.prototype.debug = function () {}\\n\\nMinimatch.prototype.make = make\\nfunction make () {\\n  // don't do it more than once.\\n  if (this._made) return\\n\\n  var pattern = this.pattern\\n  var options = this.options\\n\\n  // empty patterns and comments match nothing.\\n  if (!options.nocomment && pattern.charAt(0) === '#') {\\n    this.comment = true\\n    return\\n  }\\n  if (!pattern) {\\n    this.empty = true\\n    return\\n  }\\n\\n  // step 1: figure out negation, etc.\\n  this.parseNegate()\\n\\n  // step 2: expand braces\\n  var set = this.globSet = this.braceExpand()\\n\\n  if (options.debug) this.debug = console.error\\n\\n  this.debug(this.pattern, set)\\n\\n  // step 3: now we have a set, so turn each one into a series of path-portion\\n  // matching patterns.\\n  // These will be regexps, except in the case of \\\"**\\\", which is\\n  // set to the GLOBSTAR object for globstar behavior,\\n  // and will not contain any / characters\\n  set = this.globParts = set.map(function (s) {\\n    return s.split(slashSplit)\\n  })\\n\\n  this.debug(this.pattern, set)\\n\\n  // glob --\\u003e regexps\\n  set = set.map(function (s, si, set) {\\n    return s.map(this.parse, this)\\n  }, this)\\n\\n  this.debug(this.pattern, set)\\n\\n  // filter out everything that didn't compile properly.\\n  set = set.filter(function (s) {\\n    return s.indexOf(false) === -1\\n  })\\n\\n  this.debug(this.pattern, set)\\n\\n  this.set = set\\n}\\n\\nMinimatch.prototype.parseNegate = parseNegate\\nfunction parseNegate () {\\n  var pattern = this.pattern\\n  var negate = false\\n  var options = this.options\\n  var negateOffset = 0\\n\\n  if (options.nonegate) return\\n\\n  for (var i = 0, l = pattern.length\\n    ; i < l && pattern.charAt(i) === '!'\\n    ; i++) {\\n    negate = !negate\\n    negateOffset++\\n  }\\n\\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\\n  this.negate = negate\\n}\\n\\n// Brace expansion:\\n// a{b,c}d -> abd acd\\n// a{b,}c -> abc ac\\n// a{0..3}d -> a0d a1d a2d a3d\\n// a{b,c{d,e}f}g -> abg acdfg acefg\\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\\n//\\n// Invalid sets are not expanded.\\n// a{2..}b -> a{2..}b\\n// a{b}c -> a{b}c\\nminimatch.braceExpand = function (pattern, options) {\\n  return braceExpand(pattern, options)\\n}\\n\\nMinimatch.prototype.braceExpand = braceExpand\\n\\nfunction braceExpand (pattern, options) {\\n  if (!options) {\\n    if (this instanceof Minimatch) {\\n      options = this.options\\n    } else {\\n      options = {}\\n    }\\n  }\\n\\n  pattern = typeof pattern === 'undefined'\\n    ? this.pattern : pattern\\n\\n  if (typeof pattern === 'undefined') {\\n    throw new TypeError('undefined pattern')\\n  }\\n\\n  if (options.nobrace ||\\n    !pattern.match(/\\\\{.*\\\\}/)) {\\n    // shortcut. no need to expand.\\n    return [pattern]\\n  }\\n\\n  return expand(pattern)\\n}\\n\\n// parse a component of the expanded set.\\n// At this point, no pattern may contain \\\"/\\\" in it\\n// so we're going to return a 2d array, where each entry is the full\\n// pattern, split on '/', and then turned into a regular expression.\\n// A regexp is made at the end which joins each array with an\\n// escaped /, and another full one which joins each regexp with |.\\n//\\n// Following the lead of Bash 4.1, note that \\\"**\\\" only has special meaning\\n// when it is the *only* thing in a path portion.  Otherwise, any series\\n// of * is equivalent to a single *.  Globstar behavior is enabled by\\n// default, and can be disabled by setting options.noglobstar.\\nMinimatch.prototype.parse = parse\\nvar SUBPARSE = {}\\nfunction parse (pattern, isSub) {\\n  if (pattern.length > 1024 * 64) {\\n    throw new TypeError('pattern is too long')\\n  }\\n\\n  var options = this.options\\n\\n  // shortcuts\\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\\n  if (pattern === '') return ''\\n\\n  var re = ''\\n  var hasMagic = !!options.nocase\\n  var escaping = false\\n  // ? => one single character\\n  var patternListStack = []\\n  var negativeLists = []\\n  var stateChar\\n  var inClass = false\\n  var reClassStart = -1\\n  var classStart = -1\\n  // . and .. never match anything that doesn't start with .,\\n  // even when options.dot is set.\\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\\n  // not (start or / followed by . or .. followed by / or end)\\n  : options.dot ? '(?!(?:^|\\\\\\\\\\\\/)\\\\\\\\.{1,2}(?:$|\\\\\\\\\\\\/))'\\n  : '(?!\\\\\\\\.)'\\n  var self = this\\n\\n  function clearStateChar () {\\n    if (stateChar) {\\n      // we had some state-tracking character\\n      // that wasn't consumed by this pass.\\n      switch (stateChar) {\\n        case '*':\\n          re += star\\n          hasMagic = true\\n        break\\n        case '?':\\n          re += qmark\\n          hasMagic = true\\n        break\\n        default:\\n          re += '\\\\\\\\' + stateChar\\n        break\\n      }\\n      self.debug('clearStateChar %j %j', stateChar, re)\\n      stateChar = false\\n    }\\n  }\\n\\n  for (var i = 0, len = pattern.length, c\\n    ; (i < len) && (c = pattern.charAt(i))\\n    ; i++) {\\n    this.debug('%s\\\\t%s %s %j', pattern, i, re, c)\\n\\n    // skip over any that are escaped.\\n    if (escaping && reSpecials[c]) {\\n      re += '\\\\\\\\' + c\\n      escaping = false\\n      continue\\n    }\\n\\n    switch (c) {\\n      case '/':\\n        // completely not allowed, even escaped.\\n        // Should already be path-split by now.\\n        return false\\n\\n      case '\\\\\\\\':\\n        clearStateChar()\\n        escaping = true\\n      continue\\n\\n      // the various stateChar values\\n      // for the \\\"extglob\\\" stuff.\\n      case '?':\\n      case '*':\\n      case '+':\\n      case '@':\\n      case '!':\\n        this.debug('%s\\\\t%s %s %j <-- stateChar', pattern, i, re, c)\\n\\n        // all of those are literals inside a class, except that\\n        // the glob [!a] means [^a] in regexp\\n        if (inClass) {\\n          this.debug('  in class')\\n          if (c === '!' && i === classStart + 1) c = '^'\\n          re += c\\n          continue\\n        }\\n\\n        // if we already have a stateChar, then it means\\n        // that there was something like ** or +? in there.\\n        // Handle the stateChar, then proceed with this one.\\n        self.debug('call clearStateChar %j', stateChar)\\n        clearStateChar()\\n        stateChar = c\\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\\n        // just clear the statechar *now*, rather than even diving into\\n        // the patternList stuff.\\n        if (options.noext) clearStateChar()\\n      continue\\n\\n      case '(':\\n        if (inClass) {\\n          re += '('\\n          continue\\n        }\\n\\n        if (!stateChar) {\\n          re += '\\\\\\\\('\\n          continue\\n        }\\n\\n        patternListStack.push({\\n          type: stateChar,\\n          start: i - 1,\\n          reStart: re.length,\\n          open: plTypes[stateChar].open,\\n          close: plTypes[stateChar].close\\n        })\\n        // negation is (?:(?!js)[^/]*)\\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\\n        this.debug('plType %j %j', stateChar, re)\\n        stateChar = false\\n      continue\\n\\n      case ')':\\n        if (inClass || !patternListStack.length) {\\n          re += '\\\\\\\\)'\\n          continue\\n        }\\n\\n        clearStateChar()\\n        hasMagic = true\\n        var pl = patternListStack.pop()\\n        // negation is (?:(?!js)[^/]*)\\n        // The others are (?:<pattern>)<type>\\n        re += pl.close\\n        if (pl.type === '!') {\\n          negativeLists.push(pl)\\n        }\\n        pl.reEnd = re.length\\n      continue\\n\\n      case '|':\\n        if (inClass || !patternListStack.length || escaping) {\\n          re += '\\\\\\\\|'\\n          escaping = false\\n          continue\\n        }\\n\\n        clearStateChar()\\n        re += '|'\\n      continue\\n\\n      // these are mostly the same in regexp and glob\\n      case '[':\\n        // swallow any state-tracking char before the [\\n        clearStateChar()\\n\\n        if (inClass) {\\n          re += '\\\\\\\\' + c\\n          continue\\n        }\\n\\n        inClass = true\\n        classStart = i\\n        reClassStart = re.length\\n        re += c\\n      continue\\n\\n      case ']':\\n        //  a right bracket shall lose its special\\n        //  meaning and represent itself in\\n        //  a bracket expression if it occurs\\n        //  first in the list.  -- POSIX.2 2.8.3.2\\n        if (i === classStart + 1 || !inClass) {\\n          re += '\\\\\\\\' + c\\n          escaping = false\\n          continue\\n        }\\n\\n        // handle the case where we left a class open.\\n        // \\\"[z-a]\\\" is valid, equivalent to \\\"\\\\[z-a\\\\]\\\"\\n        if (inClass) {\\n          // split where the last [ was, make sure we don't have\\n          // an invalid re. if so, re-walk the contents of the\\n          // would-be class to re-translate any characters that\\n          // were passed through as-is\\n          // TODO: It would probably be faster to determine this\\n          // without a try/catch and a new RegExp, but it's tricky\\n          // to do safely.  For now, this is safe and works.\\n          var cs = pattern.substring(classStart + 1, i)\\n          try {\\n            RegExp('[' + cs + ']')\\n          } catch (er) {\\n            // not a valid class!\\n            var sp = this.parse(cs, SUBPARSE)\\n            re = re.substr(0, reClassStart) + '\\\\\\\\[' + sp[0] + '\\\\\\\\]'\\n            hasMagic = hasMagic || sp[1]\\n            inClass = false\\n            continue\\n          }\\n        }\\n\\n        // finish up the class.\\n        hasMagic = true\\n        inClass = false\\n        re += c\\n      continue\\n\\n      default:\\n        // swallow any state char that wasn't consumed\\n        clearStateChar()\\n\\n        if (escaping) {\\n          // no need\\n          escaping = false\\n        } else if (reSpecials[c]\\n          && !(c === '^' && inClass)) {\\n          re += '\\\\\\\\'\\n        }\\n\\n        re += c\\n\\n    } // switch\\n  } // for\\n\\n  // handle the case where we left a class open.\\n  // \\\"[abc\\\" is valid, equivalent to \\\"\\\\[abc\\\"\\n  if (inClass) {\\n    // split where the last [ was, and escape it\\n    // this is a huge pita.  We now have to re-walk\\n    // the contents of the would-be class to re-translate\\n    // any characters that were passed through as-is\\n    cs = pattern.substr(classStart + 1)\\n    sp = this.parse(cs, SUBPARSE)\\n    re = re.substr(0, reClassStart) + '\\\\\\\\[' + sp[0]\\n    hasMagic = hasMagic || sp[1]\\n  }\\n\\n  // handle the case where we had a +( thing at the *end*\\n  // of the pattern.\\n  // each pattern list stack adds 3 chars, and we need to go through\\n  // and escape any | chars that were passed through as-is for the regexp.\\n  // Go through and escape them, taking care not to double-escape any\\n  // | chars that were already escaped.\\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\\n    var tail = re.slice(pl.reStart + pl.open.length)\\n    this.debug('setting tail', re, pl)\\n    // maybe some even number of \\\\, then maybe 1 \\\\, followed by a |\\n    tail = tail.replace(/((?:\\\\\\\\{2}){0,64})(\\\\\\\\?)\\\\|/g, function (_, $1, $2) {\\n      if (!$2) {\\n        // the | isn't already escaped, so escape it.\\n        $2 = '\\\\\\\\'\\n      }\\n\\n      // need to escape all those slashes *again*, without escaping the\\n      // one that we need for escaping the | character.  As it works out,\\n      // escaping an even number of slashes can be done by simply repeating\\n      // it exactly after itself.  That's why this trick works.\\n      //\\n      // I am sorry that you have to see this.\\n      return $1 + $1 + $2 + '|'\\n    })\\n\\n    this.debug('tail=%j\\\\n   %s', tail, tail, pl, re)\\n    var t = pl.type === '*' ? star\\n      : pl.type === '?' ? qmark\\n      : '\\\\\\\\' + pl.type\\n\\n    hasMagic = true\\n    re = re.slice(0, pl.reStart) + t + '\\\\\\\\(' + tail\\n  }\\n\\n  // handle trailing things that only matter at the very end.\\n  clearStateChar()\\n  if (escaping) {\\n    // trailing \\\\\\\\\\n    re += '\\\\\\\\\\\\\\\\'\\n  }\\n\\n  // only need to apply the nodot start if the re starts with\\n  // something that could conceivably capture a dot\\n  var addPatternStart = false\\n  switch (re.charAt(0)) {\\n    case '.':\\n    case '[':\\n    case '(': addPatternStart = true\\n  }\\n\\n  // Hack to work around lack of negative lookbehind in JS\\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\\n  // lookahead, has to look ALL the way ahead, to the end of\\n  // the pattern.\\n  for (var n = negativeLists.length - 1; n > -1; n--) {\\n    var nl = negativeLists[n]\\n\\n    var nlBefore = re.slice(0, nl.reStart)\\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\\n    var nlAfter = re.slice(nl.reEnd)\\n\\n    nlLast += nlAfter\\n\\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\\n    // mean that we should *not* include the ) in the bit that is considered\\n    // \\\"after\\\" the negated section.\\n    var openParensBefore = nlBefore.split('(').length - 1\\n    var cleanAfter = nlAfter\\n    for (i = 0; i < openParensBefore; i++) {\\n      cleanAfter = cleanAfter.replace(/\\\\)[+*?]?/, '')\\n    }\\n    nlAfter = cleanAfter\\n\\n    var dollar = ''\\n    if (nlAfter === '' && isSub !== SUBPARSE) {\\n      dollar = '$'\\n    }\\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\\n    re = newRe\\n  }\\n\\n  // if the re is not \\\"\\\" at this point, then we need to make sure\\n  // it doesn't match against an empty path part.\\n  // Otherwise a/* will match a/, which it should not.\\n  if (re !== '' && hasMagic) {\\n    re = '(?=.)' + re\\n  }\\n\\n  if (addPatternStart) {\\n    re = patternStart + re\\n  }\\n\\n  // parsing just a piece of a larger pattern.\\n  if (isSub === SUBPARSE) {\\n    return [re, hasMagic]\\n  }\\n\\n  // skip the regexp for non-magical patterns\\n  // unescape anything in it, though, so that it'll be\\n  // an exact match against a file etc.\\n  if (!hasMagic) {\\n    return globUnescape(pattern)\\n  }\\n\\n  var flags = options.nocase ? 'i' : ''\\n  try {\\n    var regExp = new RegExp('^' + re + '$', flags)\\n  } catch (er) {\\n    // If it was an invalid regular expression, then it can't match\\n    // anything.  This trick looks for a character after the end of\\n    // the string, which is of course impossible, except in multi-line\\n    // mode, but it's not a /m regex.\\n    return new RegExp('$.')\\n  }\\n\\n  regExp._glob = pattern\\n  regExp._src = re\\n\\n  return regExp\\n}\\n\\nminimatch.makeRe = function (pattern, options) {\\n  return new Minimatch(pattern, options || {}).makeRe()\\n}\\n\\nMinimatch.prototype.makeRe = makeRe\\nfunction makeRe () {\\n  if (this.regexp || this.regexp === false) return this.regexp\\n\\n  // at this point, this.set is a 2d array of partial\\n  // pattern strings, or \\\"**\\\".\\n  //\\n  // It's better to use .match().  This function shouldn't\\n  // be used, really, but it's pretty convenient sometimes,\\n  // when you just want to work with a regex.\\n  var set = this.set\\n\\n  if (!set.length) {\\n    this.regexp = false\\n    return this.regexp\\n  }\\n  var options = this.options\\n\\n  var twoStar = options.noglobstar ? star\\n    : options.dot ? twoStarDot\\n    : twoStarNoDot\\n  var flags = options.nocase ? 'i' : ''\\n\\n  var re = set.map(function (pattern) {\\n    return pattern.map(function (p) {\\n      return (p === GLOBSTAR) ? twoStar\\n      : (typeof p === 'string') ? regExpEscape(p)\\n      : p._src\\n    }).join('\\\\\\\\\\\\/')\\n  }).join('|')\\n\\n  // must match entire pattern\\n  // ending in a * or ** will make it less strict.\\n  re = '^(?:' + re + ')$'\\n\\n  // can match anything, as long as it's not this.\\n  if (this.negate) re = '^(?!' + re + ').*$'\\n\\n  try {\\n    this.regexp = new RegExp(re, flags)\\n  } catch (ex) {\\n    this.regexp = false\\n  }\\n  return this.regexp\\n}\\n\\nminimatch.match = function (list, pattern, options) {\\n  options = options || {}\\n  var mm = new Minimatch(pattern, options)\\n  list = list.filter(function (f) {\\n    return mm.match(f)\\n  })\\n  if (mm.options.nonull && !list.length) {\\n    list.push(pattern)\\n  }\\n  return list\\n}\\n\\nMinimatch.prototype.match = match\\nfunction match (f, partial) {\\n  this.debug('match', f, this.pattern)\\n  // short-circuit in the case of busted things.\\n  // comments, etc.\\n  if (this.comment) return false\\n  if (this.empty) return f === ''\\n\\n  if (f === '/' && partial) return true\\n\\n  var options = this.options\\n\\n  // windows: need to use /, not \\\\\\n  if (path.sep !== '/') {\\n    f = f.split(path.sep).join('/')\\n  }\\n\\n  // treat the test path as a set of pathparts.\\n  f = f.split(slashSplit)\\n  this.debug(this.pattern, 'split', f)\\n\\n  // just ONE of the pattern sets in this.set needs to match\\n  // in order for it to be valid.  If negating, then just one\\n  // match means that we have failed.\\n  // Either way, return on the first hit.\\n\\n  var set = this.set\\n  this.debug(this.pattern, 'set', set)\\n\\n  // Find the basename of the path by looking for the last non-empty segment\\n  var filename\\n  var i\\n  for (i = f.length - 1; i >= 0; i--) {\\n    filename = f[i]\\n    if (filename) break\\n  }\\n\\n  for (i = 0; i < set.length; i++) {\\n    var pattern = set[i]\\n    var file = f\\n    if (options.matchBase && pattern.length === 1) {\\n      file = [filename]\\n    }\\n    var hit = this.matchOne(file, pattern, partial)\\n    if (hit) {\\n      if (options.flipNegate) return true\\n      return !this.negate\\n    }\\n  }\\n\\n  // didn't get any hits.  this is success if it's a negative\\n  // pattern, failure otherwise.\\n  if (options.flipNegate) return false\\n  return this.negate\\n}\\n\\n// set partial to true to test if, for example,\\n// \\\"/a/b\\\" matches the start of \\\"/*/b/*/d\\\"\\n// Partial means, if you run out of file before you run\\n// out of pattern, then that's fine, as long as all\\n// the parts match.\\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\\n  var options = this.options\\n\\n  this.debug('matchOne',\\n    { 'this': this, file: file, pattern: pattern })\\n\\n  this.debug('matchOne', file.length, pattern.length)\\n\\n  for (var fi = 0,\\n      pi = 0,\\n      fl = file.length,\\n      pl = pattern.length\\n      ; (fi < fl) && (pi < pl)\\n      ; fi++, pi++) {\\n    this.debug('matchOne loop')\\n    var p = pattern[pi]\\n    var f = file[fi]\\n\\n    this.debug(pattern, p, f)\\n\\n    // should be impossible.\\n    // some invalid regexp stuff in the set.\\n    if (p === false) return false\\n\\n    if (p === GLOBSTAR) {\\n      this.debug('GLOBSTAR', [pattern, p, f])\\n\\n      // \\\"**\\\"\\n      // a/**/b/**/c would match the following:\\n      // a/b/x/y/z/c\\n      // a/x/y/z/b/c\\n      // a/b/x/b/x/c\\n      // a/b/c\\n      // To do this, take the rest of the pattern after\\n      // the **, and see if it would match the file remainder.\\n      // If so, return success.\\n      // If not, the ** \\\"swallows\\\" a segment, and try again.\\n      // This is recursively awful.\\n      //\\n      // a/**/b/**/c matching a/b/x/y/z/c\\n      // - a matches a\\n      // - doublestar\\n      //   - matchOne(b/x/y/z/c, b/**/c)\\n      //     - b matches b\\n      //     - doublestar\\n      //       - matchOne(x/y/z/c, c) -> no\\n      //       - matchOne(y/z/c, c) -> no\\n      //       - matchOne(z/c, c) -> no\\n      //       - matchOne(c, c) yes, hit\\n      var fr = fi\\n      var pr = pi + 1\\n      if (pr === pl) {\\n        this.debug('** at the end')\\n        // a ** at the end will just swallow the rest.\\n        // We have found a match.\\n        // however, it will not swallow /.x, unless\\n        // options.dot is set.\\n        // . and .. are *never* matched by **, for explosively\\n        // exponential reasons.\\n        for (; fi < fl; fi++) {\\n          if (file[fi] === '.' || file[fi] === '..' ||\\n            (!options.dot && file[fi].charAt(0) === '.')) return false\\n        }\\n        return true\\n      }\\n\\n      // ok, let's see if we can swallow whatever we can.\\n      while (fr < fl) {\\n        var swallowee = file[fr]\\n\\n        this.debug('\\\\nglobstar while', file, fr, pattern, pr, swallowee)\\n\\n        // XXX remove this slice.  Just pass the start index.\\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\\n          this.debug('globstar found match!', fr, fl, swallowee)\\n          // found a match.\\n          return true\\n        } else {\\n          // can't swallow \\\".\\\" or \\\"..\\\" ever.\\n          // can only swallow \\\".foo\\\" when explicitly asked.\\n          if (swallowee === '.' || swallowee === '..' ||\\n            (!options.dot && swallowee.charAt(0) === '.')) {\\n            this.debug('dot detected!', file, fr, pattern, pr)\\n            break\\n          }\\n\\n          // ** swallows a segment, and continue.\\n          this.debug('globstar swallow a segment, and continue')\\n          fr++\\n        }\\n      }\\n\\n      // no match was found.\\n      // However, in partial mode, we can't say this is necessarily over.\\n      // If there's more *pattern* left, then\\n      if (partial) {\\n        // ran out of file\\n        this.debug('\\\\n>>> no match, partial?', file, fr, pattern, pr)\\n        if (fr === fl) return true\\n      }\\n      return false\\n    }\\n\\n    // something other than **\\n    // non-magic patterns just have to match exactly\\n    // patterns with magic have been turned into regexps.\\n    var hit\\n    if (typeof p === 'string') {\\n      if (options.nocase) {\\n        hit = f.toLowerCase() === p.toLowerCase()\\n      } else {\\n        hit = f === p\\n      }\\n      this.debug('string match', p, f, hit)\\n    } else {\\n      hit = f.match(p)\\n      this.debug('pattern match', p, f, hit)\\n    }\\n\\n    if (!hit) return false\\n  }\\n\\n  // Note: ending in / means that we'll get a final \\\"\\\"\\n  // at the end of the pattern.  This can only match a\\n  // corresponding \\\"\\\" at the end of the file.\\n  // If the file ends in /, then it can only match a\\n  // a pattern that ends in /, unless the pattern just\\n  // doesn't have any more for it. But, a/b/ should *not*\\n  // match \\\"a/b/*\\\", even though \\\"\\\" matches against the\\n  // [^/]*? pattern, except in partial mode, where it might\\n  // simply not be reached yet.\\n  // However, a/b/ should still satisfy a/*\\n\\n  // now either we fell off the end of the pattern, or we're done.\\n  if (fi === fl && pi === pl) {\\n    // ran out of pattern and filename at the same time.\\n    // an exact hit!\\n    return true\\n  } else if (fi === fl) {\\n    // ran out of file, but still had pattern left.\\n    // this is ok if we're doing the match as part of\\n    // a glob fs traversal.\\n    return partial\\n  } else if (pi === pl) {\\n    // ran out of pattern, still have file left.\\n    // this is only acceptable if we're on the very last\\n    // empty segment of a file with a trailing slash.\\n    // a/* should match a/b/\\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\\n    return emptyFileEnd\\n  }\\n\\n  // should be unreachable.\\n  throw new Error('wtf?')\\n}\\n\\n// replace stuff like \\\\* with *\\nfunction globUnescape (s) {\\n  return s.replace(/\\\\\\\\(.)/g, '$1')\\n}\\n\\nfunction regExpEscape (s) {\\n  return s.replace(/[-[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g, '\\\\\\\\$&')\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ext\",\"a\",\"b\",\"t\",\"Object\",\"keys\",\"forEach\",\"k\",\"minimatch\",\"p\",\"pattern\",\"options\",\"TypeError\",\"nocomment\",\"charAt\",\"trim\",\"match\",\"Minimatch\",\"path\",\"sep\",\"split\",\"join\",\"set\",\"regexp\",\"empty\",\"comment\",\"negate\",\"make\",\"braceExpand\",\"nobrace\",\"expand\",\"er\",\"GLOBSTAR\",\"plTypes\",\"open\",\"close\",\"reSpecials\",\"charSet\",\"s\",\"reduce\",\"c\",\"slashSplit\",\"filter\",\"i\",\"list\",\"defaults\",\"minimatch.defaults\",\"def\",\"length\",\"m\",\"m.Minimatch\",\"Minimatch.defaults\",\"prototype\",\"debug\",\"Minimatch.prototype.debug\",\"_made\",\"parseNegate\",\"globSet\",\"console\",\"error\",\"globParts\",\"map\",\"si\",\"parse\",\"indexOf\",\"negateOffset\",\"nonegate\",\"l\",\"substr\",\"minimatch.braceExpand\",\"isSub\",\"clearStateChar\",\"stateChar\",\"re\",\"star\",\"hasMagic\",\"qmark\",\"self\",\"noglobstar\",\"nocase\",\"escaping\",\"patternListStack\",\"negativeLists\",\"inClass\",\"reClassStart\",\"classStart\",\"patternStart\",\"dot\",\"len\",\"noext\",\"push\",\"type\",\"start\",\"reStart\",\"pl\",\"pop\",\"reEnd\",\"cs\",\"substring\",\"RegExp\",\"sp\",\"SUBPARSE\",\"tail\",\"slice\",\"replace\",\"_\",\"$1\",\"$2\",\"addPatternStart\",\"n\",\"nl\",\"nlBefore\",\"nlFirst\",\"nlLast\",\"nlAfter\",\"openParensBefore\",\"cleanAfter\",\"dollar\",\"flags\",\"regExp\",\"_glob\",\"_src\",\"makeRe\",\"minimatch.makeRe\",\"twoStar\",\"twoStarDot\",\"twoStarNoDot\",\"ex\",\"minimatch.match\",\"mm\",\"f\",\"nonull\",\"partial\",\"filename\",\"file\",\"matchBase\",\"matchOne\",\"hit\",\"flipNegate\",\"Minimatch.prototype.matchOne\",\"fi\",\"pi\",\"fl\",\"fr\",\"pr\",\"swallowee\",\"toLowerCase\",\"Error\"]\n}\n"]