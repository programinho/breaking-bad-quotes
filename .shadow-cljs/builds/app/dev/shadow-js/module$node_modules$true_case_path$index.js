["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/true-case-path/index.js"],"~:js","shadow$provide.module$node_modules$true_case_path$index=function(global,require,module,exports){var process=require(\"module$node_modules$process$browser\");\"use strict\";var glob=require(\"module$node_modules$glob$glob\"),path=require(\"module$node_modules$path_browserify$index\");module.exports=function(fsPath){var fsPathNormalized=path.normalize(fsPath);\"darwin\"===process.platform&&(fsPathNormalized=fsPathNormalized.normalize(\"NFD\"));fsPath=path.parse(fsPathNormalized).root;fsPathNormalized=fsPathNormalized.slice(Math.max(fsPath.length-\n1,0));return glob.sync(fsPathNormalized,{nocase:!0,cwd:fsPath})[0]}}","~:source","shadow$provide[\"module$node_modules$true_case_path$index\"] = function(global,require,module,exports) {\nvar process = require('process');\n'use strict'\r\n\r\nvar glob = require('glob')\r\nvar path = require('path')\r\n\r\nfunction trueCasePathSync(fsPath) {\r\n\r\n  // Normalize the path so as to resolve . and .. components.\r\n  // !! As of Node v4.1.1, a path starting with ../ is NOT resolved relative\r\n  // !! to the current dir, and glob.sync() below then fails.\r\n  // !! When in doubt, resolve with fs.realPathSync() *beforehand*.\r\n  var fsPathNormalized = path.normalize(fsPath)\r\n\r\n  // OSX: HFS+ stores filenames in NFD (decomposed normal form) Unicode format,\r\n  // so we must ensure that the input path is in that format first.\r\n  if (process.platform === 'darwin') fsPathNormalized = fsPathNormalized.normalize('NFD')\r\n\r\n  // !! Windows: Curiously, the drive component mustn't be part of a glob,\r\n  // !! otherwise glob.sync() will invariably match nothing.\r\n  // !! Thus, we remove the drive component and instead pass it in as the 'cwd'\r\n  // !! (working dir.) property below.\r\n  var pathRoot = path.parse(fsPathNormalized).root\r\n  var noDrivePath = fsPathNormalized.slice(Math.max(pathRoot.length - 1, 0))\r\n\r\n  // Perform case-insensitive globbing (on Windows, relative to the drive /\r\n  // network share) and return the 1st match, if any.\r\n  // Fortunately, glob() with nocase case-corrects the input even if it is\r\n  // a *literal* path.\r\n  return glob.sync(noDrivePath, { nocase: true, cwd: pathRoot })[0]\r\n}\r\n\r\nmodule.exports = trueCasePathSync\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$shadow.js","~$module$node_modules$path_browserify$index","~$module$node_modules$glob$glob"]],"~:properties",["^5",["cwd","nocase"]],"~:compiled-at",1562407149200,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$true_case_path$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,yCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACrG,IAAIC,QAAUH,OAAA,CAAQ,qCAAR,CACd,aAEA,KAAII,KAAOJ,OAAA,CAAQ,+BAAR,CAAX,CACIK,KAAOL,OAAA,CAAQ,2CAAR,CA4BXC,OAAAC,QAAA,CA1BAI,QAAyB,CAACC,MAAD,CAAS,CAMhC,IAAIC,iBAAmBH,IAAAI,UAAA,CAAeF,MAAf,CAIE,SAAzB,GAAIJ,OAAAO,SAAJ,GAAmCF,gBAAnC,CAAsDA,gBAAAC,UAAA,CAA2B,KAA3B,CAAtD,CAMIE,OAAAA,CAAWN,IAAAO,MAAA,CAAWJ,gBAAX,CAAAK,KACXC,iBAAAA,CAAcN,gBAAAO,MAAA,CAAuBC,IAAAC,IAAA,CAASN,MAAAO,OAAT;AAA2B,CAA3B,CAA8B,CAA9B,CAAvB,CAMlB,OAAOd,KAAAe,KAAA,CAAUL,gBAAV,CAAuB,CAAEM,OAAQ,CAAA,CAAV,CAAgBC,IAAKV,MAArB,CAAvB,CAAA,CAAwD,CAAxD,CAvByB,CAPmE;\",\n\"sources\":[\"node_modules/true-case-path/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$true_case_path$index\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n'use strict'\\r\\n\\r\\nvar glob = require('glob')\\r\\nvar path = require('path')\\r\\n\\r\\nfunction trueCasePathSync(fsPath) {\\r\\n\\r\\n  // Normalize the path so as to resolve . and .. components.\\r\\n  // !! As of Node v4.1.1, a path starting with ../ is NOT resolved relative\\r\\n  // !! to the current dir, and glob.sync() below then fails.\\r\\n  // !! When in doubt, resolve with fs.realPathSync() *beforehand*.\\r\\n  var fsPathNormalized = path.normalize(fsPath)\\r\\n\\r\\n  // OSX: HFS+ stores filenames in NFD (decomposed normal form) Unicode format,\\r\\n  // so we must ensure that the input path is in that format first.\\r\\n  if (process.platform === 'darwin') fsPathNormalized = fsPathNormalized.normalize('NFD')\\r\\n\\r\\n  // !! Windows: Curiously, the drive component mustn't be part of a glob,\\r\\n  // !! otherwise glob.sync() will invariably match nothing.\\r\\n  // !! Thus, we remove the drive component and instead pass it in as the 'cwd'\\r\\n  // !! (working dir.) property below.\\r\\n  var pathRoot = path.parse(fsPathNormalized).root\\r\\n  var noDrivePath = fsPathNormalized.slice(Math.max(pathRoot.length - 1, 0))\\r\\n\\r\\n  // Perform case-insensitive globbing (on Windows, relative to the drive /\\r\\n  // network share) and return the 1st match, if any.\\r\\n  // Fortunately, glob() with nocase case-corrects the input even if it is\\r\\n  // a *literal* path.\\r\\n  return glob.sync(noDrivePath, { nocase: true, cwd: pathRoot })[0]\\r\\n}\\r\\n\\r\\nmodule.exports = trueCasePathSync\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"process\",\"glob\",\"path\",\"trueCasePathSync\",\"fsPath\",\"fsPathNormalized\",\"normalize\",\"platform\",\"pathRoot\",\"parse\",\"root\",\"noDrivePath\",\"slice\",\"Math\",\"max\",\"length\",\"sync\",\"nocase\",\"cwd\"]\n}\n"]