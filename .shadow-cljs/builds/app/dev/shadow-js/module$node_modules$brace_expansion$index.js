["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/brace-expansion/index.js"],"~:js","shadow$provide.module$node_modules$brace_expansion$index=function(global,require,module,exports){function numeric(str){return parseInt(str,10)==str?parseInt(str,10):str.charCodeAt(0)}function unescapeBraces(str){return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\")}function parseCommaParts(str){if(!str)return[\"\"];var parts=[],m=balanced(\"{\",\"}\",str);if(!m)return str.split(\",\");var body=m.body;str=m.post;m=m.pre.split(\",\");\nm[m.length-1]+=\"{\"+body+\"}\";body=parseCommaParts(str);str.length&&(m[m.length-1]+=body.shift(),m.push.apply(m,body));parts.push.apply(parts,m);return parts}function embrace(str){return\"{\"+str+\"}\"}function isPadded(el){return/^-?0\\d/.test(el)}function lte(i,y){return i<=y}function gte(i,y){return i>=y}function expand(str,isTop){var expansions=[],m=balanced(\"{\",\"}\",str);if(!m||/\\$$/.test(m.pre))return[str];var isNumericSequence=/^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body),isAlphaSequence=/^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\nisNumericSequence=isNumericSequence||isAlphaSequence;var isOptions=0<=m.body.indexOf(\",\");if(!isNumericSequence&&!isOptions)return m.post.match(/,.*\\}/)?(str=m.pre+\"{\"+m.body+escClose+m.post,expand(str)):[str];if(isNumericSequence)var n=m.body.split(/\\.\\./);else if(n=parseCommaParts(m.body),1===n.length&&(n=expand(n[0],!1).map(embrace),1===n.length))return str=m.post.length?expand(m.post,!1):[\"\"],str.map(function(p){return m.pre+n[0]+p});isOptions=m.pre;str=m.post.length?expand(m.post,!1):[\"\"];var N;\nif(isNumericSequence){var x=numeric(n[0]),y=numeric(n[1]),width=Math.max(n[0].length,n[1].length),incr=3==n.length?Math.abs(numeric(n[2])):1,test=lte;y<x&&(incr*=-1,test=gte);var pad=n.some(isPadded);for(N=[];test(x,y);x+=incr){if(isAlphaSequence){var c=String.fromCharCode(x);\"\\\\\"===c&&(c=\"\")}else if(c=String(x),pad){var need=width-c.length;0<need&&(need=Array(need+1).join(\"0\"),c=0>x?\"-\"+need+c.slice(1):need+c)}N.push(c)}}else N=concatMap(n,function(el){return expand(el,!1)});for(isAlphaSequence=\n0;isAlphaSequence<N.length;isAlphaSequence++)for(y=0;y<str.length;y++)width=isOptions+N[isAlphaSequence]+str[y],(!isTop||isNumericSequence||width)&&expansions.push(width);return expansions}var concatMap=require(\"module$node_modules$concat_map$index\"),balanced=require(\"module$node_modules$balanced_match$index\");module.exports=function(str){if(!str)return[];\"{}\"===str.substr(0,2)&&(str=\"\\\\{\\\\}\"+str.substr(2));return expand(str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod),\n!0).map(unescapeBraces)};var escSlash=\"\\x00SLASH\"+Math.random()+\"\\x00\",escOpen=\"\\x00OPEN\"+Math.random()+\"\\x00\",escClose=\"\\x00CLOSE\"+Math.random()+\"\\x00\",escComma=\"\\x00COMMA\"+Math.random()+\"\\x00\",escPeriod=\"\\x00PERIOD\"+Math.random()+\"\\x00\"}","~:source","shadow$provide[\"module$node_modules$brace_expansion$index\"] = function(global,require,module,exports) {\nvar concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$concat_map$index","~$shadow.js","~$module$node_modules$balanced_match$index"]],"~:properties",["^5",[]],"~:compiled-at",1562407149185,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$brace_expansion$index.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/brace-expansion/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$brace_expansion$index\\\"] = function(global,require,module,exports) {\\nvar concatMap = require('concat-map');\\nvar balanced = require('balanced-match');\\n\\nmodule.exports = expandTop;\\n\\nvar escSlash = '\\\\0SLASH'+Math.random()+'\\\\0';\\nvar escOpen = '\\\\0OPEN'+Math.random()+'\\\\0';\\nvar escClose = '\\\\0CLOSE'+Math.random()+'\\\\0';\\nvar escComma = '\\\\0COMMA'+Math.random()+'\\\\0';\\nvar escPeriod = '\\\\0PERIOD'+Math.random()+'\\\\0';\\n\\nfunction numeric(str) {\\n  return parseInt(str, 10) == str\\n    ? parseInt(str, 10)\\n    : str.charCodeAt(0);\\n}\\n\\nfunction escapeBraces(str) {\\n  return str.split('\\\\\\\\\\\\\\\\').join(escSlash)\\n            .split('\\\\\\\\{').join(escOpen)\\n            .split('\\\\\\\\}').join(escClose)\\n            .split('\\\\\\\\,').join(escComma)\\n            .split('\\\\\\\\.').join(escPeriod);\\n}\\n\\nfunction unescapeBraces(str) {\\n  return str.split(escSlash).join('\\\\\\\\')\\n            .split(escOpen).join('{')\\n            .split(escClose).join('}')\\n            .split(escComma).join(',')\\n            .split(escPeriod).join('.');\\n}\\n\\n\\n// Basically just str.split(\\\",\\\"), but handling cases\\n// where we have nested braced sections, which should be\\n// treated as individual members, like {a,{b,c},d}\\nfunction parseCommaParts(str) {\\n  if (!str)\\n    return [''];\\n\\n  var parts = [];\\n  var m = balanced('{', '}', str);\\n\\n  if (!m)\\n    return str.split(',');\\n\\n  var pre = m.pre;\\n  var body = m.body;\\n  var post = m.post;\\n  var p = pre.split(',');\\n\\n  p[p.length-1] += '{' + body + '}';\\n  var postParts = parseCommaParts(post);\\n  if (post.length) {\\n    p[p.length-1] += postParts.shift();\\n    p.push.apply(p, postParts);\\n  }\\n\\n  parts.push.apply(parts, p);\\n\\n  return parts;\\n}\\n\\nfunction expandTop(str) {\\n  if (!str)\\n    return [];\\n\\n  // I don't know why Bash 4.3 does this, but it does.\\n  // Anything starting with {} will have the first two bytes preserved\\n  // but *only* at the top level, so {},a}b will not expand to anything,\\n  // but a{},b}c will be expanded to [a}c,abc].\\n  // One could argue that this is a bug in Bash, but since the goal of\\n  // this module is to match Bash's rules, we escape a leading {}\\n  if (str.substr(0, 2) === '{}') {\\n    str = '\\\\\\\\{\\\\\\\\}' + str.substr(2);\\n  }\\n\\n  return expand(escapeBraces(str), true).map(unescapeBraces);\\n}\\n\\nfunction identity(e) {\\n  return e;\\n}\\n\\nfunction embrace(str) {\\n  return '{' + str + '}';\\n}\\nfunction isPadded(el) {\\n  return /^-?0\\\\d/.test(el);\\n}\\n\\nfunction lte(i, y) {\\n  return i <= y;\\n}\\nfunction gte(i, y) {\\n  return i >= y;\\n}\\n\\nfunction expand(str, isTop) {\\n  var expansions = [];\\n\\n  var m = balanced('{', '}', str);\\n  if (!m || /\\\\$$/.test(m.pre)) return [str];\\n\\n  var isNumericSequence = /^-?\\\\d+\\\\.\\\\.-?\\\\d+(?:\\\\.\\\\.-?\\\\d+)?$/.test(m.body);\\n  var isAlphaSequence = /^[a-zA-Z]\\\\.\\\\.[a-zA-Z](?:\\\\.\\\\.-?\\\\d+)?$/.test(m.body);\\n  var isSequence = isNumericSequence || isAlphaSequence;\\n  var isOptions = m.body.indexOf(',') >= 0;\\n  if (!isSequence && !isOptions) {\\n    // {a},b}\\n    if (m.post.match(/,.*\\\\}/)) {\\n      str = m.pre + '{' + m.body + escClose + m.post;\\n      return expand(str);\\n    }\\n    return [str];\\n  }\\n\\n  var n;\\n  if (isSequence) {\\n    n = m.body.split(/\\\\.\\\\./);\\n  } else {\\n    n = parseCommaParts(m.body);\\n    if (n.length === 1) {\\n      // x{{a,b}}y ==> x{a}y x{b}y\\n      n = expand(n[0], false).map(embrace);\\n      if (n.length === 1) {\\n        var post = m.post.length\\n          ? expand(m.post, false)\\n          : [''];\\n        return post.map(function(p) {\\n          return m.pre + n[0] + p;\\n        });\\n      }\\n    }\\n  }\\n\\n  // at this point, n is the parts, and we know it's not a comma set\\n  // with a single entry.\\n\\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\\n  var pre = m.pre;\\n  var post = m.post.length\\n    ? expand(m.post, false)\\n    : [''];\\n\\n  var N;\\n\\n  if (isSequence) {\\n    var x = numeric(n[0]);\\n    var y = numeric(n[1]);\\n    var width = Math.max(n[0].length, n[1].length)\\n    var incr = n.length == 3\\n      ? Math.abs(numeric(n[2]))\\n      : 1;\\n    var test = lte;\\n    var reverse = y < x;\\n    if (reverse) {\\n      incr *= -1;\\n      test = gte;\\n    }\\n    var pad = n.some(isPadded);\\n\\n    N = [];\\n\\n    for (var i = x; test(i, y); i += incr) {\\n      var c;\\n      if (isAlphaSequence) {\\n        c = String.fromCharCode(i);\\n        if (c === '\\\\\\\\')\\n          c = '';\\n      } else {\\n        c = String(i);\\n        if (pad) {\\n          var need = width - c.length;\\n          if (need > 0) {\\n            var z = new Array(need + 1).join('0');\\n            if (i < 0)\\n              c = '-' + z + c.slice(1);\\n            else\\n              c = z + c;\\n          }\\n        }\\n      }\\n      N.push(c);\\n    }\\n  } else {\\n    N = concatMap(n, function(el) { return expand(el, false) });\\n  }\\n\\n  for (var j = 0; j < N.length; j++) {\\n    for (var k = 0; k < post.length; k++) {\\n      var expansion = pre + N[j] + post[k];\\n      if (!isTop || isSequence || expansion)\\n        expansions.push(expansion);\\n    }\\n  }\\n\\n  return expansions;\\n}\\n\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"numeric\",\"str\",\"parseInt\",\"charCodeAt\",\"unescapeBraces\",\"split\",\"escSlash\",\"join\",\"escOpen\",\"escClose\",\"escComma\",\"escPeriod\",\"parseCommaParts\",\"parts\",\"m\",\"balanced\",\"body\",\"post\",\"p\",\"pre\",\"length\",\"postParts\",\"shift\",\"push\",\"apply\",\"embrace\",\"isPadded\",\"el\",\"test\",\"lte\",\"i\",\"y\",\"gte\",\"expand\",\"isTop\",\"expansions\",\"isNumericSequence\",\"isAlphaSequence\",\"isSequence\",\"isOptions\",\"indexOf\",\"match\",\"n\",\"map\",\"N\",\"x\",\"width\",\"Math\",\"max\",\"incr\",\"abs\",\"pad\",\"some\",\"c\",\"String\",\"fromCharCode\",\"need\",\"z\",\"Array\",\"slice\",\"concatMap\",\"j\",\"k\",\"expansion\",\"expandTop\",\"substr\",\"random\"]\n}\n"]